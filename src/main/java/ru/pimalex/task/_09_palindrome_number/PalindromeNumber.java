package ru.pimalex.task._09_palindrome_number;

/**
 * #09 Palindrome Number <br>
 * <a href="https://leetcode.com/problems/palindrome-number/">code on leetcode</a> <br>
 * <a href="https://www.youtube.com/watch?v=dv1FBcKpYYg">видео разбор от Евгения</a> <br>
 * <p>
 * Если данное число x является палиндромом, вернуть true, в противном случае вернуть false.
 * <p>
 * Example 1:
 * Input: x = 121
 * Output: true
 * Explanation: 121 reads as 121 from left to right and from right to left.
 * <p>
 * Example 2:
 * Input: x = -121
 * Output: false
 * Explanation: From left to right, it reads -121. From right to left, it becomes 121-.
 * Therefore, it is not a palindrome. Т.е. все отрицательные числа не являются палиндромом.
 * <p>
 * Example 3:
 * Input: x = 10
 * Output: false
 * Explanation: Reads 01 from right to left. Therefore, it is not a palindrome.
 * Подход 1: вернуть половину числа
 * <p>
 * Объяснение решения:
 * Первая идея, которая приходит в голову, — преобразовать число в строку и проверить,
 * является ли строка палиндромом, но это потребует дополнительного непостоянного пространства
 * для создания строки, что не разрешено описанием задачи.
 * Второй идеей было бы вернуть само число, а затем сравнить число с исходным числом, если они
 * одинаковы, то число является палиндромом. Однако, если обратное число больше, чем Integer.MAX,
 * мы столкнемся с проблемой целочисленного переполнения.
 * <p>
 * Следуя мыслям, основанным на второй идее, чтобы избежать проблемы переполнения возвращенного числа,
 * что, если мы вернем только половину числа? Ведь реверс последней половины палиндрома должен быть таким же,
 * как и у первой половины числа, если число является палиндромом.
 * <p>
 * Например, если ввод равен 1221, если мы можем вернуть последнюю часть числа «12 21 » из « 21 » в « 12 » и
 * сравнить ее с первой половиной числа «12», поскольку 12 — это одно и то же как 12, мы знаем, что число является палиндромом.
 * <p>
 * Давайте посмотрим, как мы можем воплотить эту идею в алгоритм.
 * <p>
 * Алгоритм
 * <p>
 * Прежде всего, мы должны позаботиться о некоторых пограничных случаях. Все отрицательные числа не являются палиндромами,
 * например: -123 не является палиндромом, поскольку «-» не равно «3». Таким образом, мы можем вернуть false для всех
 * отрицательных чисел.
 * <p>
 * Теперь давайте подумаем, как вернуть последнюю половину числа. Для числа 1221, если мы это сделаем 1221 % 10, мы
 * получим последнюю цифру 1, чтобы получить от второй до последней цифры, нам нужно удалить последнюю цифру из 1221,
 * мы могли бы сделать это, разделив ее на 10, 1221 / 10 = 122. Затем мы можем снова получить последнюю цифру, выполнив
 * деление по модулю на 10, 122 % 10 = 2 и если мы умножим последнюю цифру на 10 и добавим вторую последнюю цифру, 1 * 10 + 2 = 12
 * это даст нам преобразованное число, которое мы хотим. Продолжение этого процесса даст нам возвращенное число с большим количеством цифр.
 * <p>
 * Теперь вопрос в том, как мы узнаем, что достигли половины числа?
 * <p>
 * Поскольку мы разделили число на 10 и умножили обратное число на 10, когда исходное число меньше обратного числа, это означает,
 * что мы обработали половину цифр числа.
 */
public class PalindromeNumber {

    public static void main(String[] args) {

        //в этом цикле хотел протестировать и посмотреть какие числа остаются после % 10
        for (int i = 1; i < 1000; i++) {
            int x = i % 10;
            int y = i / 10;
            System.out.printf(" деление %d на 10 -> %d%n", i, y);
            // вывода остатка от деления на 10
            System.out.printf(" вывода остатка от деления на 10 : (%d %% 10) = %d%n", i, x);
            //хочу здесь посмотреть, какой остаток при делении по модулю на 10
            //Можно экранировать знак процента, добавив перед ним еще один знак процента.
            if (x == 0) {
                System.out.printf(" бинго (%d %% 10) = %d%n", i, x);
            }
        }
        System.out.println("----------");
        System.out.println(isPalindrome(3071703));
    }

    public static boolean isPalindrome(int x) {
        // 153
        // 351
        //return 153 == 351 - false
        // 151
        // 151
        //return 151 == 151 - true

        //обработка ситуации с отрицательным числом
        if (x < 0) {
            return false;
        }
        if (x % 10 == 0 && x != 0) {
            return false;
        }

        int invertedNumber = 0;
        //сделаем копию входящего числа, чтоб не потерять
        int copyOfX = x;

        //здесь мы просто разворачиваем число наоборот, почти как в ReverseInteger
        while (copyOfX != 0) {
            //invertedNumber * 10 - добавить нолик в конце
            //copyOfX % 10 - остаток от деления на 10
            //copyOfX / 10 - отнимаем нолик в конце
            invertedNumber = invertedNumber * 10 + copyOfX % 10;
            System.out.printf("  --- invertedNumber = %d%n", invertedNumber);
            copyOfX = copyOfX / 10;
            System.out.printf("  === copyOfX = %d%n", copyOfX);
        }
        System.out.println("развернутое число - " + invertedNumber);
        return invertedNumber == x;
    }
}
